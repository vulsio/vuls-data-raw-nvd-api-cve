{
	"id": "CVE-2025-21681",
	"sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
	"vulnStatus": "Undergoing Analysis",
	"published": "2025-01-31T12:15:29.260",
	"lastModified": "2025-01-31T12:15:29.260",
	"descriptions": [
		{
			"lang": "en",
			"value": "In the Linux kernel, the following vulnerability has been resolved:\n\nopenvswitch: fix lockup on tx to unregistering netdev with carrier\n\nCommit in a fixes tag attempted to fix the issue in the following\nsequence of calls:\n\n    do_output\n    -> ovs_vport_send\n       -> dev_queue_xmit\n          -> __dev_queue_xmit\n             -> netdev_core_pick_tx\n                -> skb_tx_hash\n\nWhen device is unregistering, the 'dev->real_num_tx_queues' goes to\nzero and the 'while (unlikely(hash >= qcount))' loop inside the\n'skb_tx_hash' becomes infinite, locking up the core forever.\n\nBut unfortunately, checking just the carrier status is not enough to\nfix the issue, because some devices may still be in unregistering\nstate while reporting carrier status OK.\n\nOne example of such device is a net/dummy.  It sets carrier ON\non start, but it doesn't implement .ndo_stop to set the carrier off.\nAnd it makes sense, because dummy doesn't really have a carrier.\nTherefore, while this device is unregistering, it's still easy to hit\nthe infinite loop in the skb_tx_hash() from the OVS datapath.  There\nmight be other drivers that do the same, but dummy by itself is\nimportant for the OVS ecosystem, because it is frequently used as a\npacket sink for tcpdump while debugging OVS deployments.  And when the\nissue is hit, the only way to recover is to reboot.\n\nFix that by also checking if the device is running.  The running\nstate is handled by the net core during unregistering, so it covers\nunregistering case better, and we don't really need to send packets\nto devices that are not running anyway.\n\nWhile only checking the running state might be enough, the carrier\ncheck is preserved.  The running and the carrier states seem disjoined\nthroughout the code and different drivers.  And other core functions\nlike __dev_direct_xmit() check both before attempting to transmit\na packet.  So, it seems safer to check both flags in OVS as well."
		},
		{
			"lang": "es",
			"value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: openvswitch: fix lockup on tx to unregistering netdev with carrier Commit en una etiqueta fixes intentó solucionar el problema en la siguiente secuencia de llamadas: do_output -&gt; ovs_vport_send -&gt; dev_queue_xmit -&gt; __dev_queue_xmit -&gt; netdev_core_pick_tx -&gt; skb_tx_hash Cuando el dispositivo está anulando el registro, 'dev-&gt;real_num_tx_queues' va a cero y el bucle 'while (unlikely(hash &gt;= qcount))' dentro de 'skb_tx_hash' se vuelve infinito, bloqueando el núcleo para siempre. Pero desafortunadamente, verificar solo el estado del operador no es suficiente para solucionar el problema, porque algunos dispositivos aún pueden estar en estado de anulación de registro mientras informan que el estado del operador es correcto. Un ejemplo de dicho dispositivo es un net/dummy. Activa el operador al iniciar, pero no implementa .ndo_stop para desactivarlo. Y tiene sentido, porque dummy en realidad no tiene un operador. Por lo tanto, mientras este dispositivo se está anulando el registro, sigue siendo fácil alcanzar el bucle infinito en skb_tx_hash() desde la ruta de datos de OVS. Puede haber otros controladores que hagan lo mismo, pero dummy por sí solo es importante para el ecosistema OVS, porque se usa con frecuencia como un receptor de paquetes para tcpdump mientras se depuran las implementaciones de OVS. Y cuando se produce el problema, la única forma de recuperarse es reiniciar. Solucione eso comprobando también si el dispositivo está en ejecución. El estado de ejecución controla el núcleo de red durante la anulación del registro, por lo que cubre mejor el caso de anulación del registro y realmente no necesitamos enviar paquetes a dispositivos que no se están ejecutando de todos modos. Si bien solo comprobar el estado de ejecución puede ser suficiente, la comprobación del operador se conserva. Los estados de ejecución y del operador parecen estar separados en todo el código y en los diferentes controladores. Y otras funciones básicas como __dev_direct_xmit() comprueban ambos antes de intentar transmitir un paquete. Por lo tanto, parece más seguro comprobar también ambos indicadores en OVS."
		}
	],
	"references": [
		{
			"source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
			"url": "https://git.kernel.org/stable/c/47e55e4b410f7d552e43011baa5be1aab4093990"
		},
		{
			"source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
			"url": "https://git.kernel.org/stable/c/82f433e8dd0629e16681edf6039d094b5518d8ed"
		},
		{
			"source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
			"url": "https://git.kernel.org/stable/c/ea966b6698785fb9cd0fdb867acd91b222e4723f"
		},
		{
			"source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
			"url": "https://git.kernel.org/stable/c/ea9e990356b7bee95440ba0e6e83cc4d701afaca"
		}
	],
	"metrics": {}
}
