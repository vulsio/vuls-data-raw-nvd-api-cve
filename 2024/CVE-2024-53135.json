{
	"id": "CVE-2024-53135",
	"sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
	"vulnStatus": "Awaiting Analysis",
	"published": "2024-12-04T15:15:13.630",
	"lastModified": "2024-12-04T15:15:13.630",
	"descriptions": [
		{
			"lang": "en",
			"value": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: VMX: Bury Intel PT virtualization (guest/host mode) behind CONFIG_BROKEN\n\nHide KVM's pt_mode module param behind CONFIG_BROKEN, i.e. disable support\nfor virtualizing Intel PT via guest/host mode unless BROKEN=y.  There are\nmyriad bugs in the implementation, some of which are fatal to the guest,\nand others which put the stability and health of the host at risk.\n\nFor guest fatalities, the most glaring issue is that KVM fails to ensure\ntracing is disabled, and *stays* disabled prior to VM-Enter, which is\nnecessary as hardware disallows loading (the guest's) RTIT_CTL if tracing\nis enabled (enforced via a VMX consistency check).  Per the SDM:\n\n  If the logical processor is operating with Intel PT enabled (if\n  IA32_RTIT_CTL.TraceEn = 1) at the time of VM entry, the \"load\n  IA32_RTIT_CTL\" VM-entry control must be 0.\n\nOn the host side, KVM doesn't validate the guest CPUID configuration\nprovided by userspace, and even worse, uses the guest configuration to\ndecide what MSRs to save/load at VM-Enter and VM-Exit.  E.g. configuring\nguest CPUID to enumerate more address ranges than are supported in hardware\nwill result in KVM trying to passthrough, save, and load non-existent MSRs,\nwhich generates a variety of WARNs, ToPA ERRORs in the host, a potential\ndeadlock, etc."
		},
		{
			"lang": "es",
			"value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: KVM: VMX: oculta la virtualización de Intel PT (modo invitado/host) detrás de CONFIG_BROKEN Oculta el parámetro del módulo pt_mode de KVM detrás de CONFIG_BROKEN, es decir, deshabilita la compatibilidad con la virtualización de Intel PT a través del modo invitado/host a menos que BROKEN=y. Hay una gran cantidad de errores en la implementación, algunos de los cuales son fatales para el invitado y otros que ponen en riesgo la estabilidad y la salud del host. Para las fatalidades del invitado, el problema más evidente es que KVM no garantiza que el seguimiento esté deshabilitado y *permanece* deshabilitado antes de VM-Enter, lo que es necesario ya que el hardware no permite cargar RTIT_CTL (del invitado) si el seguimiento está habilitado (lo que se aplica a través de una verificación de consistencia de VMX). Según el SDM: si el procesador lógico está funcionando con Intel PT habilitado (si IA32_RTIT_CTL.TraceEn = 1) en el momento de la entrada de la VM, el control de entrada de la VM \"cargar IA32_RTIT_CTL\" debe ser 0. En el lado del host, KVM no valida la configuración de CPUID del invitado proporcionada por el espacio de usuario y, lo que es peor, utiliza la configuración del invitado para decidir qué MSR guardar/cargar en VM-Enter y VM-Exit. Por ejemplo, configurar la CPUID del invitado para enumerar más rangos de direcciones de los que admite el hardware hará que KVM intente pasar, guardar y cargar MSR inexistentes, lo que genera una variedad de WARN, ERRORES ToPA en el host, un posible bloqueo, etc."
		}
	],
	"references": [
		{
			"source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
			"url": "https://git.kernel.org/stable/c/aa0d42cacf093a6fcca872edc954f6f812926a17"
		},
		{
			"source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
			"url": "https://git.kernel.org/stable/c/b91bb0ce5cd7005b376eac690ec664c1b56372ec"
		},
		{
			"source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
			"url": "https://git.kernel.org/stable/c/d28b059ee4779b5102c5da6e929762520510e406"
		},
		{
			"source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
			"url": "https://git.kernel.org/stable/c/e6716f4230a8784957273ddd27326264b27b9313"
		}
	],
	"metrics": {}
}
