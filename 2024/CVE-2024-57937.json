{
	"id": "CVE-2024-57937",
	"sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
	"vulnStatus": "Received",
	"published": "2025-01-21T12:15:27.360",
	"lastModified": "2025-01-21T12:15:27.360",
	"descriptions": [
		{
			"lang": "en",
			"value": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm: reinstate ability to map write-sealed memfd mappings read-only\n\nPatch series \"mm: reinstate ability to map write-sealed memfd mappings\nread-only\".\n\nIn commit 158978945f31 (\"mm: perform the mapping_map_writable() check\nafter call_mmap()\") (and preceding changes in the same series) it became\npossible to mmap() F_SEAL_WRITE sealed memfd mappings read-only.\n\nCommit 5de195060b2e (\"mm: resolve faulty mmap_region() error path\nbehaviour\") unintentionally undid this logic by moving the\nmapping_map_writable() check before the shmem_mmap() hook is invoked,\nthereby regressing this change.\n\nThis series reworks how we both permit write-sealed mappings being mapped\nread-only and disallow mprotect() from undoing the write-seal, fixing this\nregression.\n\nWe also add a regression test to ensure that we do not accidentally\nregress this in future.\n\nThanks to Julian Orth for reporting this regression.\n\n\nThis patch (of 2):\n\nIn commit 158978945f31 (\"mm: perform the mapping_map_writable() check\nafter call_mmap()\") (and preceding changes in the same series) it became\npossible to mmap() F_SEAL_WRITE sealed memfd mappings read-only.\n\nThis was previously unnecessarily disallowed, despite the man page\ndocumentation indicating that it would be, thereby limiting the usefulness\nof F_SEAL_WRITE logic.\n\nWe fixed this by adapting logic that existed for the F_SEAL_FUTURE_WRITE\nseal (one which disallows future writes to the memfd) to also be used for\nF_SEAL_WRITE.\n\nFor background - the F_SEAL_FUTURE_WRITE seal clears VM_MAYWRITE for a\nread-only mapping to disallow mprotect() from overriding the seal - an\noperation performed by seal_check_write(), invoked from shmem_mmap(), the\nf_op->mmap() hook used by shmem mappings.\n\nBy extending this to F_SEAL_WRITE and critically - checking\nmapping_map_writable() to determine if we may map the memfd AFTER we\ninvoke shmem_mmap() - the desired logic becomes possible.  This is because\nmapping_map_writable() explicitly checks for VM_MAYWRITE, which we will\nhave cleared.\n\nCommit 5de195060b2e (\"mm: resolve faulty mmap_region() error path\nbehaviour\") unintentionally undid this logic by moving the\nmapping_map_writable() check before the shmem_mmap() hook is invoked,\nthereby regressing this change.\n\nWe reinstate this functionality by moving the check out of shmem_mmap()\nand instead performing it in do_mmap() at the point at which VMA flags are\nbeing determined, which seems in any case to be a more appropriate place\nin which to make this determination.\n\nIn order to achieve this we rework memfd seal logic to allow us access to\nthis information using existing logic and eliminate the clearing of\nVM_MAYWRITE from seal_check_write() which we are performing in do_mmap()\ninstead."
		},
		{
			"lang": "es",
			"value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: mm: restablecer la capacidad de mapear asignaciones memfd selladas a escritura como de solo lectura Serie de parches \"mm: restablecer la capacidad de mapear asignaciones memfd selladas a escritura como de solo lectura\". En el commit 158978945f31 (\"mm: realizar la comprobación mapping_map_writable() después de call_mmap()\") (y cambios anteriores en la misma serie) se hizo posible mmap() F_SEAL_WRITE asignaciones memfd selladas como de solo lectura. El commit 5de195060b2e (\"mm: resolver el comportamiento defectuoso de la ruta de error mmap_region()\") deshizo involuntariamente esta lógica al mover la comprobación mapping_map_writable() antes de que se invoque el gancho shmem_mmap(), lo que hizo que este cambio retrocediera. Esta serie reelabora la forma en que permitimos que las asignaciones selladas de escritura se asignen a solo lectura y no permitimos que mprotect() deshaga el sello de escritura, solucionando esta regresión. También agregamos una prueba de regresión para asegurarnos de que no retrocedamos accidentalmente esto en el futuro. Gracias a Julian Orth por informar esta regresión. Este parche (de 2): En el commit 158978945f31 (\"mm: realizar la comprobación mapping_map_writable() después de call_mmap()\") (y cambios anteriores en la misma serie) se hizo posible mmap() asignaciones de memfd selladas de F_SEAL_WRITE a solo lectura. Esto anteriormente se deshabilitaba innecesariamente, a pesar de que la documentación de la página del manual indicaba que lo estaría, lo que limitaba la utilidad de la lógica de F_SEAL_WRITE. Hemos corregido esto adaptando la lógica que existía para el sello F_SEAL_FUTURE_WRITE (uno que no permite escrituras futuras en el memfd) para que también se use para F_SEAL_WRITE. En segundo plano, el sello F_SEAL_FUTURE_WRITE borra VM_MAYWRITE para una asignación de solo lectura para no permitir que mprotect() anule el sello, una operación realizada por seal_check_write(), invocada desde shmem_mmap(), el gancho f_op-&gt;mmap() utilizado por las asignaciones de shmem. Al extender esto a F_SEAL_WRITE y, críticamente, verificar mapping_map_writable() para determinar si podemos asignar el memfd DESPUÉS de invocar shmem_mmap(), la lógica deseada se vuelve posible. Esto se debe a que mapping_map_writable() verifica explícitamente VM_MAYWRITE, que habremos borrado. El commit 5de195060b2e (\"mm: resolver el comportamiento de la ruta de error mmap_region() defectuoso\") deshizo esta lógica sin querer al mover la comprobación mapping_map_writable() antes de que se invoque el gancho shmem_mmap(), lo que hace que este cambio se repita. Restablecemos esta funcionalidad al mover la comprobación de shmem_mmap() y, en su lugar, realizarla en do_mmap() en el punto en el que se están determinando los indicadores VMA, que parece ser, en cualquier caso, un lugar más apropiado para realizar esta determinación. Para lograr esto, rediseñamos la lógica del sello memfd para permitirnos acceder a esta información utilizando la lógica existente y eliminar la limpieza de VM_MAYWRITE de seal_check_write() que estamos realizando en do_mmap() en su lugar."
		}
	],
	"references": [
		{
			"source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
			"url": "https://git.kernel.org/stable/c/464770df46095e6967334d77113972960f7ef1fa"
		},
		{
			"source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
			"url": "https://git.kernel.org/stable/c/8ec396d05d1b737c87311fb7311f753b02c2a6b1"
		}
	],
	"metrics": {}
}
