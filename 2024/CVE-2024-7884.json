{
	"id": "CVE-2024-7884",
	"sourceIdentifier": "6b35d637-e00f-4228-858c-b20ad6e1d07b",
	"vulnStatus": "Undergoing Analysis",
	"published": "2024-09-05T13:15:11.390",
	"lastModified": "2024-09-05T17:45:07.877",
	"descriptions": [
		{
			"lang": "en",
			"value": "When a canister method is called via ic_cdk::call* , a new Future CallFuture is created  and can be awaited by the caller to get the execution result. Internally, the state of the Future is tracked and stored in a struct called CallFutureState.  A bug in the polling implementation of the CallFuture allows multiple references to be held for this internal state and not all references were dropped before the Future is resolved. Since we have unaccounted references held, a copy of the internal state ended up being persisted in the canister's heap and thus causing a memory leak. \nImpact Canisters built in Rust with ic_cdk and ic_cdk_timers are affected. If these canisters call a canister method, use timers or heartbeat, they will likely leak a small amount of memory on every such operation. In the worst case, this could lead to heap memory exhaustion triggered by an attacker. Motoko based canisters are not affected by the bug.\nPatchesThe patch has been backported to all minor versions between >= 0.8.0, <= 0.15.0. The patched versions available are 0.8.2, 0.9.3, 0.10.1, 0.11.6, 0.12.2, 0.13.5, 0.14.1, 0.15.1 and their previous versions have been yanked. WorkaroundsThere are no known workarounds at the moment. Developers are recommended to upgrade their canister as soon as possible to the latest available patched version of ic_cdk to avoid running out of Wasm heap memory. \nUpgrading the canisters (without updating `ic_cdk`) also frees the leaked memory but it's only a temporary solution."
		},
		{
			"lang": "es",
			"value": "Cuando se llama a un método de contenedor a través de ic_cdk::call* , se crea un nuevo Future CallFuture y el llamador puede esperar para obtener el resultado de la ejecución. Internamente, el estado del Future se rastrea y se almacena en una estructura llamada CallFutureState. Un error en la implementación de sondeo de CallFuture permite que se mantengan múltiples referencias para este estado interno y no todas las referencias se descartaron antes de que se resolviera el Future. Dado que tenemos referencias no contabilizadas retenidas, una copia del estado interno terminó siendo persistente en el montón del contenedor y, por lo tanto, causó una pérdida de memoria. Impacto Los contenedores creados en Rust con ic_cdk e ic_cdk_timers se ven afectados. Si estos contenedores llaman a un método de contenedor, usan temporizadores o latidos, es probable que pierdan una pequeña cantidad de memoria en cada una de esas operaciones. En el peor de los casos, esto podría provocar el agotamiento de la memoria del montón activado por un atacante. Los contenedores basados en Motoko no se ven afectados por el error. ParchesEl parche ha sido retroportado a todas las versiones menores entre &gt;= 0.8.0, &lt;= 0.15.0. Las versiones parcheadas disponibles son 0.8.2, 0.9.3, 0.10.1, 0.11.6, 0.12.2, 0.13.5, 0.14.1, 0.15.1 y sus versiones anteriores han sido eliminadas. Workarounds, no hay soluciones workarounds en este momento. Se recomienda a los desarrolladores que actualicen su contenedor lo antes posible a la última versión parcheada disponible de ic_cdk para evitar quedarse sin memoria del montón de Wasm. Actualizar los contenedores (sin actualizar `ic_cdk`) también libera la memoria filtrada, pero es solo una solución temporal."
		}
	],
	"references": [
		{
			"source": "6b35d637-e00f-4228-858c-b20ad6e1d07b",
			"url": "https://docs.rs/ic-cdk/latest/ic_cdk/"
		},
		{
			"source": "6b35d637-e00f-4228-858c-b20ad6e1d07b",
			"url": "https://github.com/dfinity/cdk-rs/pull/509"
		},
		{
			"source": "6b35d637-e00f-4228-858c-b20ad6e1d07b",
			"url": "https://internetcomputer.org/docs/current/references/ic-interface-spec"
		}
	],
	"metrics": {
		"cvssMetricV31": [
			{
				"source": "6b35d637-e00f-4228-858c-b20ad6e1d07b",
				"type": "Secondary",
				"cvssData": {
					"version": "3.1",
					"vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
					"attackVector": "NETWORK",
					"attackComplexity": "LOW",
					"privilegesRequired": "NONE",
					"userInteraction": "NONE",
					"scope": "UNCHANGED",
					"confidentialityImpact": "NONE",
					"integrityImpact": "NONE",
					"availabilityImpact": "HIGH",
					"baseScore": 7.5,
					"baseSeverity": "HIGH"
				},
				"exploitabilityScore": 3.9,
				"impactScore": 3.6
			}
		]
	},
	"weaknesses": [
		{
			"source": "6b35d637-e00f-4228-858c-b20ad6e1d07b",
			"type": "Secondary",
			"description": [
				{
					"lang": "en",
					"value": "CWE-401"
				}
			]
		}
	]
}
