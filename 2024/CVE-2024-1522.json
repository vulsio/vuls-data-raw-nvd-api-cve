{
	"id": "CVE-2024-1522",
	"sourceIdentifier": "security@huntr.dev",
	"vulnStatus": "Awaiting Analysis",
	"published": "2024-03-30T18:15:45.930",
	"lastModified": "2024-04-01T01:12:59.077",
	"descriptions": [
		{
			"lang": "en",
			"value": "I have activated the CORS because I had a development ui that uses another port number then I forgot to remove it.\n\nSo what I just did is :\n- First removed the cors configuration that allows everyone to access it :\nbefore:\n```python\n    sio = socketio.AsyncServer(async_mode=\"asgi\", cors_allowed_origins=\"*\", ping_timeout=1200, ping_interval=30)  # Enable CORS for every one\n```\nafter:\n```python\n    cert_file_path = lollms_paths.personal_certificates/\"cert.pem\"\n    key_file_path = lollms_paths.personal_certificates/\"key.pem\"\n    if os.path.exists(cert_file_path) and os.path.exists(key_file_path):\n        is_https = True\n    else:\n        is_https = False        \n\n    # Create a Socket.IO server\n    sio = socketio.AsyncServer(async_mode=\"asgi\", cors_allowed_origins=config.allowed_origins+[f\"https://localhost:{config['port']}\" if is_https else f\"http://localhost:{config['port']}\"], ping_timeout=1200, ping_interval=30)  # Enable CORS for selected origins\n```\n\n- Second, I have updated lollms to have two modes (a headless mode and a ui mode).\nAnd updated the /execute_code to block if the server is headless or is exposed\n```python\n@router.post(\"/execute_code\")\nasync def execute_code(request: Request):\n    \"\"\"\n    Executes Python code and returns the output.\n\n    :param request: The HTTP request object.\n    :return: A JSON response with the status of the operation.\n    \"\"\"\n    if lollmsElfServer.config.headless_server_mode:\n        return {\"status\":False,\"error\":\"Code execution is blocked when in headless mode for obvious security reasons!\"}\n\n    if lollmsElfServer.config.host==\"0.0.0.0\":\n        return {\"status\":False,\"error\":\"Code execution is blocked when the server is exposed outside for very obvipous reasons!\"}\n\n    try:\n        data = (await request.json())\n        code = data[\"code\"]\n        discussion_id = int(data.get(\"discussion_id\",\"unknown_discussion\"))\n        message_id = int(data.get(\"message_id\",\"unknown_message\"))\n        language = data.get(\"language\",\"python\")\n        \n\n\n        if language==\"python\":\n            ASCIIColors.info(\"Executing python code:\")\n            ASCIIColors.yellow(code)\n            return execute_python(code, discussion_id, message_id)\n        if language==\"javascript\":\n            ASCIIColors.info(\"Executing javascript code:\")\n            ASCIIColors.yellow(code)\n            return execute_javascript(code, discussion_id, message_id)\n        if language in [\"html\",\"html5\",\"svg\"]:\n            ASCIIColors.info(\"Executing javascript code:\")\n            ASCIIColors.yellow(code)\n            return execute_html(code, discussion_id, message_id)\n        \n        elif language==\"latex\":\n            ASCIIColors.info(\"Executing latex code:\")\n            ASCIIColors.yellow(code)\n            return execute_latex(code, discussion_id, message_id)\n        elif language in [\"bash\",\"shell\",\"cmd\",\"powershell\"]:\n            ASCIIColors.info(\"Executing shell code:\")\n            ASCIIColors.yellow(code)\n            return execute_bash(code, discussion_id, message_id)\n        elif language in [\"mermaid\"]:\n            ASCIIColors.info(\"Executing mermaid code:\")\n            ASCIIColors.yellow(code)\n            return execute_mermaid(code, discussion_id, message_id)\n        elif language in [\"graphviz\",\"dot\"]:\n            ASCIIColors.info(\"Executing graphviz code:\")\n            ASCIIColors.yellow(code)\n            return execute_graphviz(code, discussion_id, message_id)\n        return {\"status\": False, \"error\": \"Unsupported language\", \"execution_time\": 0}\n    except Exception as ex:\n        trace_exception(ex)\n        lollmsElfServer.error(ex)\n        return {\"status\":False,\"error\":str(ex)}\n```\n\nI also added an optional https mode and looking forward to add a full authentication with cookies and a personal session etc.\n\n\nAll updates will be in V 9.1 \n\n\nAgain, thanks alot for your work. I will make it harder next time, but if you find more bugs, just be my guest :)"
		},
		{
			"lang": "es",
			"value": "Activé CORS porque tenía una interfaz de usuario de desarrollo que usa otro número de puerto y luego olvidé eliminarla. Entonces, lo que acabo de hacer es: - Primero eliminé la configuración de cors que permite a todos acceder a ella: antes: ```python sio = socketio.AsyncServer(async_mode=\"asgi\", cors_allowed_origins=\"*\", ping_timeout=1200, ping_interval= 30) # Habilite CORS para cada ``` después de: ```python cert_file_path = lollms_paths.personal_certificates/\"cert.pem\" key_file_path = lollms_paths.personal_certificates/\"key.pem\" si os.path.exists(cert_file_path) y os .path.exists(key_file_path): is_https = True else: is_https = False # Crear un servidor Socket.IO sio = socketio.AsyncServer(async_mode=\"asgi\", cors_allowed_origins=config.allowed_origins+[f\"https://localhost:{ config['port']}\" if is_https else f\"http://localhost:{config['port']}\"], ping_timeout=1200, ping_interval=30) # Habilitar CORS para orígenes seleccionados ``` - Segundo, He actualizado lollms para que tenga dos modos (un modo sin cabeza y un modo ui). Y actualizó /execute_code para bloquear si el servidor no tiene cabeza o está expuesto ```python @router.post(\"/execute_code\") async def ejecutar_code(request: Request): \"\"\" Ejecuta el código Python y devuelve la salida. : solicitud de parámetro: el objeto de solicitud HTTP. :return: una respuesta JSON con el estado de la operación. \"\"\" if lollmsElfServer.config.headless_server_mode: return {\"status\":False,\"error\":\"La ejecución del código está bloqueada cuando está en ¡modo sin cabeza por razones obvias de seguridad!\"} if lollmsElfServer.config.host==\"0.0.0.0\": return {\"status\":False,\"error\":\"La ejecución del código se bloquea cuando el servidor está expuesto al exterior por razones muy obvias !\"} intente: datos = (espera solicitud.json()) código = datos[\"código\"] id_discusión = int(data.get(\"id_discusión\",\"discusión_desconocida\")) id_mensaje = int(data.get(\"id_mensaje) \",\"unknown_message\")) language = data.get(\"language\",\"python\") if language==\"python\": ASCIIColors.info(\"Ejecutando código python:\") ASCIIColors.amarillo(código) return ejecutar_python(código) , id_discusión, id_mensaje) if idioma==\"javascript\": ASCIIColors.info(\"Ejecutando código javascript:\") ASCIIColors.amarillo(código) devuelve ejecutar_javascript(código, id_discusión, id_mensaje) si el idioma está en [\"html\",\"html5\" ,\"svg\"]: ASCIIColors.info(\"Ejecutando código javascript:\") ASCIIColors.amarillo(código) return ejecutar_html(código, id_discusión, id_mensaje) elif language==\"latex\": ASCIIColors.info(\"Ejecutando código latex:\" ) ASCIIColors.amarillo(código) devuelve ejecutar_latex(código, id_discusión, id_mensaje) lenguaje elif en [\"bash\",\"shell\",\"cmd\",\"powershell\"]: ASCIIColors.info(\"Ejecutando código de shell:\") ASCIIColors. amarillo(código) devuelve ejecutar_bash(código, id_discusión, id_mensaje) idioma elif en [\"sirena\"]: ASCIIColors.info(\"Ejecutando código de sirena:\") ASCIIColors.amarillo(código) devuelve ejecutar_mermaid(código, id_discusión, id_mensaje) idioma elif en [\"graphviz\",\"punto\"]: ASCIIColors.info(\"Ejecutando código Graphviz:\") ASCIIColors.amarillo(código) return ejecutar_graphviz(código, id_discusión, id_mensaje) return {\"status\": False, \"error\": \" Idioma no admitido\", \"execution_time\": 0} excepto excepción como por ejemplo: trace_exception(ex) lollmsElfServer.error(ex) return {\"status\":False,\"error\":str(ex)} ``` También agregué un opcional modo https y esperamos agregar una autenticación completa con cookies y una sesión personal, etc. Todas las actualizaciones estarán en la versión 9.1 nuevamente, muchas gracias por su trabajo. Lo haré más difícil la próxima vez, pero si encuentras más errores, sé mi invitado :)"
		}
	],
	"references": [
		{
			"source": "security@huntr.dev",
			"url": "https://github.com/parisneo/lollms-webui/commit/0b51063119cfb5e391925d232a4af1de9dc32e2b"
		},
		{
			"source": "security@huntr.dev",
			"url": "https://huntr.com/bounties/687cef92-3432-4d6c-af92-868eccabbb71"
		}
	],
	"metrics": {
		"cvssMetricV30": [
			{
				"source": "security@huntr.dev",
				"type": "Secondary",
				"cvssData": {
					"version": "3.0",
					"vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H",
					"attackVector": "NETWORK",
					"attackComplexity": "LOW",
					"privilegesRequired": "NONE",
					"userInteraction": "REQUIRED",
					"scope": "UNCHANGED",
					"confidentialityImpact": "HIGH",
					"integrityImpact": "HIGH",
					"availabilityImpact": "HIGH",
					"baseScore": 8.8,
					"baseSeverity": "HIGH"
				},
				"exploitabilityScore": 2.8,
				"impactScore": 5.9
			}
		]
	},
	"weaknesses": [
		{
			"source": "security@huntr.dev",
			"type": "Secondary",
			"description": [
				{
					"lang": "en",
					"value": "CWE-352"
				}
			]
		}
	]
}
