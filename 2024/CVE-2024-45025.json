{
	"id": "CVE-2024-45025",
	"sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
	"vulnStatus": "Undergoing Analysis",
	"published": "2024-09-11T16:15:07.440",
	"lastModified": "2024-09-11T16:26:11.920",
	"descriptions": [
		{
			"lang": "en",
			"value": "In the Linux kernel, the following vulnerability has been resolved:\n\nfix bitmap corruption on close_range() with CLOSE_RANGE_UNSHARE\n\ncopy_fd_bitmaps(new, old, count) is expected to copy the first\ncount/BITS_PER_LONG bits from old->full_fds_bits[] and fill\nthe rest with zeroes.  What it does is copying enough words\n(BITS_TO_LONGS(count/BITS_PER_LONG)), then memsets the rest.\nThat works fine, *if* all bits past the cutoff point are\nclear.  Otherwise we are risking garbage from the last word\nwe'd copied.\n\nFor most of the callers that is true - expand_fdtable() has\ncount equal to old->max_fds, so there's no open descriptors\npast count, let alone fully occupied words in ->open_fds[],\nwhich is what bits in ->full_fds_bits[] correspond to.\n\nThe other caller (dup_fd()) passes sane_fdtable_size(old_fdt, max_fds),\nwhich is the smallest multiple of BITS_PER_LONG that covers all\nopened descriptors below max_fds.  In the common case (copying on\nfork()) max_fds is ~0U, so all opened descriptors will be below\nit and we are fine, by the same reasons why the call in expand_fdtable()\nis safe.\n\nUnfortunately, there is a case where max_fds is less than that\nand where we might, indeed, end up with junk in ->full_fds_bits[] -\nclose_range(from, to, CLOSE_RANGE_UNSHARE) with\n\t* descriptor table being currently shared\n\t* 'to' being above the current capacity of descriptor table\n\t* 'from' being just under some chunk of opened descriptors.\nIn that case we end up with observably wrong behaviour - e.g. spawn\na child with CLONE_FILES, get all descriptors in range 0..127 open,\nthen close_range(64, ~0U, CLOSE_RANGE_UNSHARE) and watch dup(0) ending\nup with descriptor #128, despite #64 being observably not open.\n\nThe minimally invasive fix would be to deal with that in dup_fd().\nIf this proves to add measurable overhead, we can go that way, but\nlet's try to fix copy_fd_bitmaps() first.\n\n* new helper: bitmap_copy_and_expand(to, from, bits_to_copy, size).\n* make copy_fd_bitmaps() take the bitmap size in words, rather than\nbits; it's 'count' argument is always a multiple of BITS_PER_LONG,\nso we are not losing any information, and that way we can use the\nsame helper for all three bitmaps - compiler will see that count\nis a multiple of BITS_PER_LONG for the large ones, so it'll generate\nplain memcpy()+memset().\n\nReproducer added to tools/testing/selftests/core/close_range_test.c"
		},
		{
			"lang": "es",
			"value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: se corrige la corrupción de mapas de bits en close_range() con CLOSE_RANGE_UNSHARE Se espera que copy_fd_bitmaps(new, old, count) copie los primeros bits count/BITS_PER_LONG de old-&gt;full_fds_bits[] y rellene el resto con ceros. Lo que hace es copiar suficientes palabras (BITS_TO_LONGS(count/BITS_PER_LONG)), luego memsets el resto. Eso funciona bien, *si* todos los bits más allá del punto de corte están limpios. De lo contrario, corremos el riesgo de basura de la última palabra que habíamos copiado. Para la mayoría de los llamadores, esto es cierto: expand_fdtable() tiene count igual a old-&gt;max_fds, por lo que no hay descriptores abiertos más allá de count, y mucho menos palabras completamente ocupadas en -&gt;open_fds[], que es a lo que corresponden los bits en -&gt;full_fds_bits[]. El otro llamador (dup_fd()) pasa sane_fdtable_size(old_fdt, max_fds), que es el múltiplo más pequeño de BITS_PER_LONG que cubre todos los descriptores abiertos por debajo de max_fds. En el caso común (copiar en fork()) max_fds es ~0U, por lo que todos los descriptores abiertos estarán por debajo de él y estamos bien, por las mismas razones por las que la llamada en expand_fdtable() es segura. Desafortunadamente, hay un caso en el que max_fds es menor que eso y en el que, de hecho, podríamos terminar con basura en -&gt;full_fds_bits[] - close_range(from, to, CLOSE_RANGE_UNSHARE) con * tabla de descriptores que se comparte actualmente * 'to' está por encima de la capacidad actual de la tabla de descriptores * 'from' está justo debajo de algún trozo de descriptores abiertos. En ese caso, terminamos con un comportamiento observablemente incorrecto, por ejemplo, generar un hijo con CLONE_FILES, obtener todos los descriptores en el rango 0..127 abiertos, luego close_range(64, ~0U, CLOSE_RANGE_UNSHARE) y ver que dup(0) termina con el descriptor #128, a pesar de que #64 no está abierta observablemente. La solución mínimamente invasiva sería lidiar con eso en dup_fd(). Si esto demuestra agregar una sobrecarga medible, podemos ir por ese camino, pero intentemos arreglar copy_fd_bitmaps() primero. * nuevo ayudante: bitmap_copy_and_expand(to, from, bits_to_copy, size). * hacer que copy_fd_bitmaps() tome el tamaño del mapa de bits en palabras, en lugar de bits; Su argumento 'count' es siempre un múltiplo de BITS_PER_LONG, por lo que no perdemos ninguna información y de esa manera podemos usar el mismo asistente para los tres mapas de bits: el compilador verá que count es un múltiplo de BITS_PER_LONG para los grandes, por lo que generará memcpy()+memset() simple. Se agregó el reproductor a tools/testing/selftests/core/close_range_test.c"
		}
	],
	"references": [
		{
			"source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
			"url": "https://git.kernel.org/stable/c/5053581fe5dfb09b58c65dd8462bf5dea71f41ff"
		},
		{
			"source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
			"url": "https://git.kernel.org/stable/c/8cad3b2b3ab81ca55f37405ffd1315bcc2948058"
		},
		{
			"source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
			"url": "https://git.kernel.org/stable/c/9a2fa1472083580b6c66bdaf291f591e1170123a"
		},
		{
			"source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
			"url": "https://git.kernel.org/stable/c/c69d18f0ac7060de724511537810f10f29a27958"
		},
		{
			"source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
			"url": "https://git.kernel.org/stable/c/dd72ae8b0fce9c0bbe9582b9b50820f0407f8d8a"
		},
		{
			"source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
			"url": "https://git.kernel.org/stable/c/e807487a1d5fd5d941f26578ae826ca815dbfcd6"
		},
		{
			"source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
			"url": "https://git.kernel.org/stable/c/ee501f827f3db02d4e599afbbc1a7f8b792d05d7"
		},
		{
			"source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
			"url": "https://git.kernel.org/stable/c/fe5bf14881701119aeeda7cf685f3c226c7380df"
		}
	],
	"metrics": {}
}
